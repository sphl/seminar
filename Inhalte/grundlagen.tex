\section{Symbolische Ausführung}

Die Grundidee der \emph{symbolischen Ausführung} besteht darin, die Anweisungen eines Programms sukzessive abzuarbeiten, ohne konkrete Werte für die Variablen anzugeben. Die dabei eingesetzten symbolischen Werte repräsentieren ganze Wertebereiche, welche entlang der Ausführung weiter eingeschränkt werden. D.h. substituiert man die symbolischen Variablen durch Werte aus deren Wertebereichen, so gelangt man wieder zu einer konkreten Programmausführung.

Programme bestehen in der Regel aus einer Vielzahl von Verzweigungen, die oftmals abhängig von Benutzerinteraktionen, Berechnungen, externen Signalen etc. ausgeführt werden. Entlang eines Programmpfades können somit die Bedingungen aller Verzweigungen zu einer logischen \emph{Pfadbedingung} (engl. \emph{path constraints}) zusammengefasst werden. Des weiteren erhält man an jedem Punkt der Ausführung einen \emph{Pfadwert}, welcher die bis dahin bekannten symbolischen Werte der Variablen angibt. D.h. Zuweisungen im Programmfluss ändern den Pfadwert, während Verzweigungen die Pfadbedingung erweitert. Der exakte \emph{Pfadzustand} lässt sich somit über die Konjunktion aus Pfadwert und Pfadbedingung bestimmen. \cite{Kneuper2008}

\begin{figure}[!hbt]
	\centering
	\input{Bilder/tree}
	\caption{Beispiel symbolische Ausführung}
	\label{fig:tree}
\end{figure}

\noindent
Der Ausführungsbaum in \cref{fig:tree} zeigt die symbolische Ausführung eines einfachen Programms $\alpha$ $\equiv$ \texttt{if (x < 0) then y = -x else y = x}. Die Pfadbedingungen stehen jeweils auf der linken Seite einer Kante, während die symbolischen Pfadwerte rechts neben den Knoten zu finden sind. Da die Bedingung aus dem symbolischen Wert $v$ nicht ersichtlich ist, müssen beide Pfade durchlaufen werden. Dabei wird die Pfadbedingung beider Zweige um die entsprechende Formel ergänzt. Die finalen Pfadzustände in $\alpha$ sind somit durch die logischen Ausdrücke $x < 0 \wedge x = v \wedge y = -x$ (links) und $x \geq 0 \wedge x = v \wedge y = x$ (rechts) gegeben.

Das Konzept der symbolischen Ausführung ist vielschichtig und mit unterschiedlichen Zielsetzungen einsetzbar. Ein mögliches Anwendungsszenario ist die Generierung von Testfällen, in der anhand der Pfadbedingungen und eines SMT Solvers Werte für unterschiedliche Programmpfade erzeugt werden können. Dies erhöht die Testabdeckung und erlaubt darüber hinaus, dass Auffinden von unerreichbaren Codeabschnitten. So könnte im oberen Beispielprogramm Werte kleiner bzw. größer/gleich Null für die Variable $x$ gefunden werden, um beide Ausführungspfade zu testen.

Ein weiteres Einsatzgebiet ist die Programmverifikation, in der neben den Pfadbedingungen auch die finalen Pfadzustände betrachtet werden. Hierbei gilt es zu zeigen, dass alle symbolische Endzustände in denen das Programm terminiert eine in der Spezifikation festlegte Eigenschaft bzw. Nachbedingung erfüllen. Eine mögliche Nachbedingung für das Programm $\alpha$ könnte hierbei sein, dass in allen finalen Pfadzuständen der Wert von $y$ großer/gleich Null ist und über das \emph{Hoare-Triple} $\{true\}\alpha\{y \geq 0\}$ ausgedrückt wird.