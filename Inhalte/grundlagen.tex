\section{Symbolische Ausführung}

Die Grundidee der \emph{symbolischen Ausführung} besteht darin, die Anweisungen eines Programms sukzessive abzuarbeiten, ohne dabei konkrete Werte für die Variablen anzugeben. Die eingesetzten symbolischen Werte repräsentieren ganze Wertebereiche, welche entlang der Ausführung weiter eingeschränkt werden \cite{Kneuper2008}. D.h. substituiert man die symbolischen Variablen durch Werte aus deren Wertebereichen, so gelangt man wieder zu einer konkreten Programmausführung.

\begin{figure}[t]
	\centering
	\input{Bilder/tree}
	\caption{Beispiel einer symbolischen Ausführung}
	\label{fig:tree}
\end{figure}

Programme bestehen in der Regel aus einer Vielzahl von Verzweigungen die abhängig von Benutzerinteraktionen, Berechnungen, externen Signalen etc. ausgeführt werden. Entlang eines Programmpfades können dabei die Bedingungen aller Verzweigungen zu einer logischen \emph{Pfadbedingung} (engl. \emph{path constraints}) zusammengefasst werden. Des weiteren erhält man an jedem Ausführungspunkt einen \emph{Pfadwert}, welcher die bis dahin bekannten symbolischen Werte der Variablen angibt. Dementsprechend verändern Zuweisungen im Programmfluss den Pfadwert, während Verzweigungen die Pfadbedingung erweitert. Der exakte \emph{Pfadzustand} lässt sich dann über die Konjunktion aus Pfadbedingung und Pfadwert bestimmen.

\cref{fig:tree} zeigt den symbolischen Ausführungsbaum des Programms $\alpha$ $\equiv$ \texttt{if \linebreak (x < 0) then y = -x else y = x}. Innerhalb der Abbildung steht die Pfadbedingungen jeweils auf der linken Seite einer Kante, während die symbolischen Pfadwerte rechts neben den Knoten zu finden sind. Da die Bedingung aus dem symbolischen Wert $v$ nicht auswertbar ist, müssen beide Pfade durchlaufen werden. Dabei wird die Pfadbedingung beider Zweige um den entsprechenden logischen Ausdruck ergänzt. Die finalen Pfadzustände in $\alpha$ sind somit durch die Formeln $x < 0 \wedge x = v \wedge y = -x$ im linken und $x \geq 0 \wedge x = v \wedge y = x$ im rechten Zweig gegeben.

Das Konzept der symbolischen Ausführung ist mit unterschiedlichen Zielsetzungen einsetzbar. Ein mögliches Anwendungsszenario ist die Generierung von Testfällen. Darin werden anhand der Pfadbedingungen und mit Hilfe eines \emph{SMT Solvers} Werte für unterschiedliche Programmpfade erzeugt. Dies erhöht die Testabdeckung und erlaubt zusätzlich das Auffinden von unerreichbaren Codeabschnitten. Im Hinblick auf das obere Beispielprogramm, könnten Werte kleiner bzw. größer oder gleich Null für die Variable $x$ gefunden werden, um beide Ausführungspfade zu testen. Ein weiteres Einsatzgebiet ist die Programmverifikation, in der neben den Pfadbedingungen auch die finalen Pfadwerte betrachtet werden. Hierbei gilt es zu zeigen, dass alle symbolischen Endzustände, in denen das Programm terminiert, eine in der Spezifikation festlegte Eigenschaft bzw. Nachbedingung erfüllen. Eine mögliche Nachbedingung für das Programm $\alpha$ könnte sein, dass in allen Pfadendzuständen $y$ ausschließlich Wert großer oder gleich Null speichert. Diese Forderung kann beispielsweise über ein \emph{Hoare-Triple} der Form $\{true\}\alpha\{y \geq 0\}$ ausgedrückt werden.