\section{Symbolische Ausführung}

Die Grundidee der \emph{symbolischen Ausführung} besteht darin, die Anweisungen eines Programms sukzessive abzuarbeiten, ohne konkrete Werte für die Variablen anzugeben. Die dabei eingesetzten symbolischen Werte repräsentieren ganze Wertebereiche, welche entlang der Ausführung weiter eingeschränkt werden. D.h. substituiert man die symbolischen Variablen durch Werte aus deren Wertebereichen, so gelangt man wieder zu einer konkreten Programmausführung.

Programme bestehen in der Regel aus einer Vielzahl von Verzweigungen, die abhängig von Benutzerinteraktionen, Berechnungen, externen Signalen etc. ausgeführt werden. Entlang eines Programmpfades können dabei die Bedingungen aller Verzweigungen zu einer logischen \emph{Pfadbedingung} (engl. \emph{path constraints}) zusammengefasst werden. Des weiteren erhält man an jedem Ausführungspunkt einen \emph{Pfadwert}, welcher die bis dahin bekannten symbolischen Werte der Variablen angibt. D.h. Zuweisungen im Programmfluss ändern den Pfadwert, während Verzweigungen die Pfadbedingung erweitert. Der exakte \emph{Pfadzustand} lässt sich dann über die Konjunktion aus Pfadwert und Pfadbedingung bestimmen. \cite{Kneuper2008}

\begin{figure}[!hbt]
	\centering
	\input{Bilder/tree}
	\caption{Beispiel einer symbolischen Ausführung}
	\label{fig:tree}
\end{figure}

\noindent
Der symbolische Ausführungsbaum in \cref{fig:tree} zeigt das Programm $\alpha$ $\equiv$ \texttt{\textbf{if} (x < 0) \textbf{then} y = -x \textbf{else} y = x}. Hierbei steht die Pfadbedingungen jeweils auf der linken Seite einer Kante, während die symbolischen Pfadwerte rechts neben den Knoten zu finden sind. Da die Bedingung aus dem symbolischen Wert $v$ nicht auswertbar ist, müssen beide Pfade durchlaufen werden. Dabei wird die Pfadbedingung beider Zweige um den entsprechenden logischen Ausdruck ergänzt. Die finalen Pfadzustände in $\alpha$ sind somit durch die Formeln $x < 0 \wedge x = v \wedge y = -x$ (links) und $x \geq 0 \wedge x = v \wedge y = x$ (rechts) gegeben.

Das Konzept der symbolischen Ausführung ist mit unterschiedlichen Zielsetzungen einsetzbar. Ein mögliches Anwendungsszenario ist die Generierung von Testfällen, in dem anhand der Pfadbedingungen und mit Hilfe eines \emph{SMT Solvers} Werte für unterschiedliche Programmpfade erzeugt werden. Dies erhöht die Testabdeckung und erlaubt zusätzlich das Auffinden von unerreichbaren Codeabschnitten. Im Hinblick auf das obere Beispielprogramm, könnten Werte kleiner bzw. größer/gleich Null für die Variable $x$ gefunden werden, um beide Ausführungspfade zu testen.

Ein weiteres Einsatzgebiet ist die Programmverifikation, in der neben den Pfadbedingungen auch die finalen Pfadzustände betrachtet werden. Hierbei gilt es zu zeigen, dass alle symbolische Endzustände in denen das Programm terminiert, eine in der Spezifikation festlegte Eigenschaft bzw. Nachbedingung erfüllen. Eine mögliche Nachbedingung für das Programm $\alpha$ könnte sein, dass in allen finalen Pfadzuständen $y$ ausschließlich Wert großer/gleich Null speichert. Diese Forderung kann über das \emph{Hoare-Triple} $\{true\}\alpha\{y \geq 0\}$ ausgedrückt werden.