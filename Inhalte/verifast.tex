\section{VeriFast}

Im Rahmen dieser Seminararbeit werden wir uns hauptsächlich mit dem Verifikationswerkzeug \emph{VeriFast} auseinandersetzen, dass in Form eines Prototypen an der KU Leuven ins Leben gerufen wurde und bis heute, Stand 2018, aktiv weiterentwickelt wird. VeriFast erlaubt die Verifikation von \emph{single-} und \emph{multithreaded} C und Java Programmen, welche mit zusätzlichen Annotationen, für die Verifikation bestimmter Korrektheitseigenschaften, ausgestattet sind. Die Annotationen stehen dabei innerhalb von Kommentaren, wodurch der verifizierte C Code ohne zusätzliche Änderungen kompiliert werden kann. Während der Ausführung von VeriFast wird das Programm auf illegale Speicherzugriffe, beispielsweise durch Dereferenzierung von Null-Pointern oder durch Zugriff auf Speicherzellen außer der Grenzen eines Arrays, sowie Fehler aufgrund nebenläufiger Ausführung geprüft. Darüber hinaus untersucht VeriFast die annotierten Methoden-Kontrakte - d.h. es wird versucht zu zeigen, dass sich die spezifizierte Nachbedingung aus der Vorbedingung und der symbolischen Ausführung des Methodenrumpfs ableiten lässt. \cite{Jacobs2010}

\begin{figure}[!hbt]
	\centering
	\includegraphics[width=0.8\linewidth]{verifast}
	\caption{VeriFast IDE}
	\label{fig:vfide}
\end{figure}

\noindent
Über die VeriFast IDE (siehe \vref{fig:vfide}) können Quellcodedateien modifiziert und Programme schrittweise oder in einem Durchlauf verifiziert werden. Im Falle eines Fehlers werden diese innerhalb des Editors lokalisiert und anhand einer Statusmeldung dem Benutzer mitgeteilt. Wurde die Verifikation erfolgreich durchlaufen, so können abhängig von der ausgewählten Funktion die getesteten Pfade in Form eines Ausführungsbaums am rechten Fensterrand angezeigt werden. Dieser erlaubt es, durch anklicken eines Blattknotens, einzelne Pfad genauer zu untersuchen. Die \emph{Steps}-Auswahl (unten links) listet dabei die ausgeführten Schritte eines Pfades auf und erlaubt Sprünge zu vorherigen bzw. nachfolgenden Zuständen. In dem Auswahlfenster nebenan befinden sich die logischen Annahmen, die sich dynamisch zur Ausführung aus den Annotationen und dem C Code ergeben. Eine weitere Besonderheit der IDE sind die \emph{heap chunks} (unten rechts), welche den symbolischen Zustand des Heap-Speichers abhängig von den Ausführungsschritt anzeigt. Direkt neben dem Editor befindet sich eine weitere Auswahl, welche einen Überblick über die Zuordnung der lokalen Variablen auf deren symbolischen Werte gibt. \cite{Jacobs2017}

\subsection{Sprachkonstrukte}

In diesem Abschnitt möchten wir uns mit einigen (Sprach-)Konzepten beschäftigten welche VeriFast für die Programmverifikation bereitstellt. Dabei werden ausschließlich die Konzepte vorgestellt, welche für das Verständnis des Beispiels aus \cref{subsec:queue} relevant sind. Weiterführende Konzepte und Beispiele können in \cite{Jacobs2017} nachgelesen werden.

\subsubsection{Induktive Datentypen}
\label{subsec:adt}

Eines der wichtigsten Hilfsmittel um die Korrektheit von Programme nachweisen zu können besteht in der Spezifikation von abstrakten Datentypen (ADT). Dadurch ist es möglich, Eigenschaften und Operationen eines Datentyps auf einem höheren Abstraktionsniveau, d.h. unabhängig von einer konkreten Implementierung auf einem Computer, zu betrachten. Daraus resultierend können ADTs in der Programmverifikation als Repräsentanten für konkrete Datenstrukturen, wie beispielsweise Array oder einfach/doppelt verkettete Listen, eingesetzt werden. \cite[S. 265]{Saake2014}

VeriFast unterstützt dabei induktiven Datentypen, deren Instanzen über die Konkatenation der definierten Konstruktoren (Konstruktorterm) gebildet werden. Die Spezifikation einer abstrakten Liste kann im nachfolgenden Beispiel gesehen werden.

\begin{lstlisting}
inductive list<t> = nil | cons(t, list<t>);
\end{lstlisting}

\noindent
In unserem oberen Beispiel definieren wir eine generische Liste mit den Konstruktoren \texttt{nil} für die leere Liste und \texttt{cons} für die zusammengesetzte Liste mit \texttt{t} als Kopfelement und \texttt{list<t>} als Restliste. Analog zu den meisten Programmiersprachen spezifiziert \texttt{<t>} den generischen Datentyp, wodurch Listen über \texttt{int}, \texttt{char}, \texttt{bool} etc. gebildet werden können. So entspricht der Konstruktorterm \texttt{cons('a', cons('b', cons('c', nil)))} einer Liste mit der Zeichenfolge \texttt{<'a', 'b', 'c'>}.

\subsubsection{Fixpunkt Funktionen}

Neben den induktiven ADTs unterstützt VeriFast die Spezifikation von Fix\-punkt-Funktionen, wodurch spezifische Operation auf abstrakten Datentypen ausgeführt werden können. Diese werden mit \texttt{fixpoint} eingeleitet und erhalten über die Parameterliste einen oder mehrere ADTs. Im Funktionsrumpf kann entweder eine \texttt{return}-Anweisung, welche die berechnete Eigenschaft direkt an den Aufrufer zurückgibt, oder eine \texttt{switch}-Anweisung stehen. Letztere führt eine Fallunterscheidung bezüglich aller Konstruktoren von genau einem induktiven Argument (Fixpunkt) aus. Zudem prüft VeriFast jede Funktion auf Terminierung - d.h. im Falle eines rekursiven Aufrufs muss der neue Fixpunkt ein Teilterm des alten Konstruktorterms sein. \cite{Jacobs2010}

Ausgehend von der induktiven Liste aus \cref{subsec:adt}, definieren wir nun die beiden Funktionen \texttt{head} und \texttt{tail} welche das Kopfelement bzw. die Restliste des Fixpunkts \texttt{xs} zurückliefert.

\begin{lstlisting}
fixpoint t head<t>(list<t> xs) {
  switch (xs) {
    case nil: return default_value<t>;
    case cons(x, xs0): return x;
  }
}

fixpoint list<t> tail<t>(list<t> xs) {
  switch (xs) {
    case nil: return nil;
    case cons(x, xs0): return xs0;
  }
}
\end{lstlisting}

\noindent
Für den Konstruktor \texttt{cons(t, list<t>)} bindet VeriFast die entsprechenden Werte an die Variablen \texttt{x} und \texttt{xs0}, welche im Anschluss beliebig weiterverwendet werden können. Ein Sonderfall in diesem Beispiel bildet der Konstruktor \texttt{nil} in \texttt{head}. Hierbei wird ein Defaultwert zurückgegeben, welcher je nach Anforderung und Datentyp unterschiedliche Werte annehmen kann.

Eine weitere bekannte Funktion auf Datentypen ist \texttt{length}, welche in unserem Beispiel die Länge einer Liste rekursiv berechnet. D.h. wurde ein Term ungleich \texttt{nil} übergeben, so wird dieser sukzessive abgebaut und zugleich die Länge um den Wert 1 erhöht. Der letzte Aufruf endet immer im \texttt{nil}-Konstruktor, welcher folgerichtig den die Länge 0 zurückgibt und damit die Berechnung abschließt.\footnote{\texttt{head}, \texttt{tail}, \texttt{length} und weitere Fixpunkt-Operation auf \texttt{list<t>} sind Bestandteil der VeriFast-Bibliothek.}

\begin{lstlisting}
fixpoint int length<t>(list<t> xs) {
  switch (xs) {
    case nil: return 0;
    case cons(x, xs0): return 1 + length(xs0);
  }
}
\end{lstlisting}

\subsubsection{malloc\_block Einheiten}

Charakteristisch für die Programmiersprache C ist die Speicherallokation mittels malloc, wodurch eine festgelegte Menge von Bytes vom Heap-Speicher angefordert werden kann und falls erfolgreich alloziert, ein Zeiger auf den Beginn des Speicherblocks zurückgegeben wird. Dies macht es allerdings erforderlich, dass der Programmierer manuell angeforderte Speicherblöcke mit Hilfe von free freigibt, falls diese nicht mehr benötigt werden.

Die Verwaltung der beiden Speicherbereich Heap und Stack gilt es auch bei der Programmverifikation zu berücksichtigen, weshalb VeriFast bei der symbolischen Ausführung dynamische allozierte Speicherstrukturen in Form von malloc\_block chunks auf dem symbolischen Heap ablegt. Im Falle eines structs wird dabei nicht nur ein chunk für Instanz der Datenstruktur angelegt, alle enthalten Felder erhalten ebenfalls einen Eintrag auf dem Heap. Welche chunks auf dem Heap liegen ist für die Verifikation von großer Bedeutung, da beispielsweise ein free nur dann erlaubt ist, wenn zuvor ein malloc\_block Eintrag auf dem Heap liegt. Die gleiche Datenstruktur könnte auch lokal instanziert worden sein (d.h. kein malloc\_block chunk), dass dann zu einem Fehler führen würde, wenn deren Adresse an free übergeben wird.

Im nachfolgenden Beispiel ist das struct node zu sehen, welche einen Knoten einer einfach verketteten Liste darstellt und dabei ein Zeichen speichert, und queue, welche jeweils die Adresse des ersten und letzten Listenelements speichert und somit die Grundstruktur für eine Queue implementiert.

\noindent
\begin{minipage}{.45\textwidth}
\begin{lstlisting}
struct node {
  struct node *next;
  char value;
};
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}
struct queue {
  struct node *first;
  struct node *last;
};
\end{lstlisting}
\end{minipage}

\noindent
Die Funktion create\_queue\footnote{\texttt{requires}, \texttt{ensures} und \texttt{close} werden in den darauffolgenden Abschnitten erklärt und können in diesem Beispiel übersprungen werden.} legt eine leere Queue auf dem Heap an, indem sie eine Queue alloziert und anschließend first und last den gleichen Knoten zu. Abschließend wird die Adresse der neu erstellten Queue an den Aufrufer zurückgeben.

\begin{lstlisting}
struct queue *create_queue()
  //@ requires true;
  //@ ensures queue(result, nil);
{
  struct queue *q = malloc(sizeof(struct queue));
  if (q == 0) { abort(); }
  struct node *n = malloc(sizeof(struct node));
  if (n == 0) { abort(); }
  q->first = n;
  q->last = n;
  //@ close nodes(n, n, nil);
  //@ close queue(q, nil);
  return q;
}
\end{lstlisting}

\noindent
Nach Ausführung dieser Funktion liegen folgende chunks auf dem Heap:

{\setlength\extrarowheight{5pt} % Vergroeßert den Zeilenabstand
\begin{table}[hbt!]
	\centering
	\begin{tabular}{|l|l|}
		\hline
		\rowcolor[HTML]{EFEFEF}
		% ----------------------------------------------------------------------------------------------------
		\textbf{Chunk}                   & \textbf{Beschreibung}                                     \\ \hline
		% ----------------------------------------------------------------------------------------------------
		\texttt{malloc\_block\_node(n)}  & Dynamisch allozierte Instanz \texttt{n}                   \\ \hline
		\texttt{malloc\_block\_queue(q)} & Dynamisch allozierte Instanz \texttt{q}                   \\ \hline
		\texttt{n->next |-> value1}      & Feld \texttt{next} hat symbolischen Wert \texttt{value1}  \\ \hline
		\texttt{n->value |-> value2}     & Feld \texttt{value} hat symbolischen Wert \texttt{value2} \\ \hline
		\texttt{q->first |-> n}          & Feld \texttt{first} zeigt auf Instanz \texttt{n}          \\ \hline
		\texttt{q->last |-> n}           & Feld \texttt{last} zeigt auf Instanz \texttt{n}           \\ \hline
		% ----------------------------------------------------------------------------------------------------
	\end{tabular}
\end{table}
}

\subsubsection{Prädikate}

\subsubsection{Kontrakte}

\subsubsection{Schleifeninvarianten}

\subsubsection{Lemma Funktionen}

\subsection{Verifikation -- Queue}
\label{subsec:queue}

\subsection{Praxis Fallstudien}

\subsubsection{Embedded Linux Network Management Software}

\subsubsection{Linux USB BP Keyboard Driver}

\subsection{Fazit}