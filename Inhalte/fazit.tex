\section{Fazit}

VeriFast ist eines der bekanntesten Verifikationswerkzeuge im C-Umfeld, dass bereits innerhalb von Java Smart Card Anwendungen, eines Linux Keyboard Gerätetreibers und einer eingebetteten Linux Netzwerkmanager Komponente eingesetzt wurde \cite{Philippaerts2013}. Dementsprechend lassen sich zahlreiche Paper, Tutorials und Beispielprogramme bezogen auf die C-Verifikation mittels VeriFast finden.

Die enthaltene Bibliothek, welche vordefinierte Datentypen und Funktionen enthält, ermöglicht eine schnelle Anwendung, sowie Hilfestellungen für weitere Definitionen. Zudem ist besonders die VeriFast IDE (vgl. \cref{fig:vfide}) hervorzuheben, die einiges an Funktionalität zur Verfügung stellt und damit den gesamten Verifikationsprozess vereinfacht. Gerade die schrittweise Ausführung bzw. Verifikation einzelner Programmpfade ermöglicht eine detaillierte Analyse, sowie das schnelle Auffinden von fehlerhaften Annotationen. Fehlermeldungen, die dem Benutzer angezeigt werden, wurden dabei sinnvoll gewählt und geben zuverlässige Hinweise auf mögliche Schwachstellen. Bestehende C-Programme jedoch erst nachträglich und ohne größere Anpassungen im Quellcode zu verifizieren, ist auch mithilfe von VeriFast in vielen Fällen nur schwer zu realisieren. Vielmehr sollte das Konzept der Programmverifikation von Beginn an in den Entwicklungsprozess einbezogen werden, wodurch Sprachlimitationen der Verifikationswerkzeuge umgangen und das Design-by-Contract Paradigma sauber und vollständig umgesetzt werden kann.

Ein weiteres Problem ist das Finden von Schleifeninvarianten, dass gerade bei komplexen Programmen eine Herausforderung darstellt. So gibt es andere Verifikationstools die hierfür eine Hilfestellung anbieten, deren Ergebnisse jedoch nicht immer sinnvoll anwendbar sind \cite{Crocker2007}. Ansätze, dies zu Automatisieren, gibt es bereits in \cite{Stark1990} und \cite{Leino2005} und könnten in zukünftigen Versionen von VeriFast integriert werden. Auch gilt es zu beachten, dass verifizierte Programme, die unterschiedlich compiliert wurden, oder auf unterschiedlicher Hardware laufen, abweichende Ergebnisse liefern können. Ein Ansatz, der diese Annahme in den Verifikationsprozess integriert, wird in \cite{Kandl2007} vorgestellt. Darin verwenden die Autoren \emph{Model Checking}, um zusätzlich zur Programmverifikation, Testfälle für eine native Testausführung zu generieren.